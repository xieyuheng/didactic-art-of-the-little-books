---
title: 起
date: 2021-12-31
---

# 目标文本

"The Little Typer" 第一章，"Chapter 1. The More Things Change, the More They Stay the Same"。

# 形而上

首先，将 [皮尔士](https://en.wikipedia.org/wiki/Charles_Sanders_Peirce) 的
[实用主义认识论](https://en.wikipedia.org/wiki/Pragmatism)
用于「工程师学习某个系统」这件事。

「学习某个系统」即「学会如何实现某个系统」。

贯穿 "The Little Typer" 的 Law 于 Commandment，
其实是实现类型系统时的 "type checking rule"
以及 "equivalence rule"（或者称为 "conversion rule"）。

# 流程纲要

- 问候
- 首次提起 `Atom`
- 用 Lisp 的 `atom` 来解释 `Atom`
- 例举 `Atom` 的实例
- 用口语描述 `Atom` 的定义
- 例举 `Atom` 的实例与反例
- 重申 `Atom` 的定义，作为 "The Law of Tick Marks"
- 首次提起 judgment，以 "is a" judgment 为例，它是口语描述的 Law 之形式化
- 例举 "is a" judgment 作用于 `Atom`
- 用口语描述 judgment 的定义
- 用例子解释 judgment 的定义
- 首次提起 from of judgment，以上面的具体 judgment 为例
- 介绍另一个 from of judgment 的实例，即 "the same as" judgment 为例
- 例举 "the same as" judgment 作用于 `Atom`
- 口语重申上面的例子，得到 "The Commandment of Tick Marks"

# 方法分析

## 用问题来引入陌生的概念

> Is it obvious that this is an `Atom`?
>
>     `'atom`

> Not at all. What does `Atom` mean?

## 给出明确的规则，然后使用这个规则

> Atoms are built from a tick mark
> directly followed by one or more letters
> and hyphens.

然后利用这个规则讨论一些 `Atom` 的例子。

之后给出一个 Law：

> **The Law of Tick Marks**
>
> A tick mark directly followed by one or more
> letters and hyphens is an Atom.

## 前置吸引人的列子

为了介绍一个新的概念，首先我们应该给出很多吸引人的列子。

## 以读者所熟悉的概念为基础

比如，

- 介绍 Atom 的时候，利用了 Lisp 中的 atom。
- 介绍一个相对形式化的概念的时候，可以先用人们更熟悉的等价的形式。
  - 比如，用散文形式的 Laws 来描述 judgment，然后才给 formal judgment。
- 在介绍更加抽象的概念之前，应该先介绍具体的概念。
  - 比如，在介绍 form of judgment 之前，先介绍 "The Law of Tick Marks" 这个具体的 judgment。
    - 正如为了理解一个 class，先熟悉它的 object (instance)。

## 在教学过程中，还不明显的地方，应该得到进一步地解释

We want to ask the question:
"Is (cons 'ratatouille 'baguette) a (Pair Atom Atom)?",

But we have not explained the meaning of Pair,
thus we ask "Is it obvious that ...",
and give a reason to explain the meaning of Pair.

Just like at the beginning of this chapter,
the first question is:

"Is it obvious that this is an Atom? -- 'atom"

And the answer is "Not at all. What does Atom mean?"

用这种方法可以逐渐将结构化的知识解构成更加线性的形式。
类似于用 stack 去实现 tree 的递归处理，
stack 相较于 tree 是更加线性的。

# Definition of Type

Expressions that describe other expressions are called types.

Xie: When we can say "x is P", that means "P" describe "x".
or in our language "the P x" is the same as "x is P".

This definition of type is very simple,
with a leading question, it is even more natural.

# The Four Forms of Judgment

2020-09-16

```
(1)                   ____ is a ____.
(2)    ____ is the same ____ as ____.
(3)                   ____ is a type.
(4)  ____ and ____ are the same type.
```

Judgments are acts of knowing, and believing is part of knowing.

Judgments are sentence.

But, Sentences get their meaning from those who understand them.
The sentences capture thoughts that we have,
and thoughts are more important than the words we use to express them.

# Definition of Normal Forms

2020-09-17

Expressions that are written differently
may nevertheless be the same,
as seen in frames 39-41.
One way of writing these expressions
is more direct than the others.

The normal form of an expression is the most direct way of writing it.

Any two expressions that are the same have identical normal forms,
and any two expressions with identical normal forms are the same.

Sameness is always according to a type,
so normal forms are also determined by a type.

- When `equivalent` is implemented by `readback` and `alpha_equivalent`,
  it is the `readback` that "is always according to a type".

Given a type, every expression described by that type has a normal form,
which is the most direct way of writing it.
If two expressions are the same,
then they have identical normal forms,
and if they have identical normal forms,
then they are the same.

- Each type can specify its own notion of equality,
  and thus the syntax of its normal forms.
  -- "NbE Tutorial", David.

但是，如果不考虑实现中 `equivalent` 与 `readback` 之类的函数，如何以 type 为参数。
为什么 `equivalent` 总是需要给定 type 才能判断的？
是否有这种情况，`x: A` 且 `x: B`，
而 `x` 以 `A` 为类型时的 normal form，
与 `x` 以 `B` 为类型时的 normal form 不同。

在 `readback` 中，根据不同的 type，为不同的 value 实现了不同的 eta-expansion。

# Value, Neutral & Normal

当 `Neutral` 想要递归引用到 `Value` 时，
应该通过带有类型的 `Value`，即 `Normal` 来引用，
因为 `Value.readback` 必须是带有类型的 readback，
其类型不应是 `(ctx: Ctx, value: Value) => Exp`，
而应该是 `(ctx: Ctx, t: Ty, value: Value) => Exp`。

# Normal Form in jojo

也许在不同类型的语义中考虑 Normal Form，对于理解 Normal Form 有帮助。
也许在 jojo 里考虑 Normal Form，对于理解 Normal Form 有帮助。

我之前认为，其中的难点在于多返回值。

也许我应该模仿 lambda 演算的定义序列，
先处理 untyped 版本的 partial evaluation。
- 定义有 reduction step 定义。
- 用 reduction step 定义有方向的 (multi-step) reduction。
- 用有方向的 reduction 定义无方向的 equivalent。

```
datatype Jo {
  v(name: String)
  let(name: String)
  jojo(list: Array(Jo))
  exe()
}

datatype Value {
  jojo(list: Array(Jo), env: Env)
}

datatype Neutral {
  jojo(list: Array(Jo), env: Env)
}
```

也许 equivalent relation 应该被定义于 jojo 而不是 jo。

reduction step:
```
... [ f g h ] ! ... => ... f g h ...
```

partial evaluation:
- 假设没有递归定义。
- inline all definitions.
- do all the reductions (including in-closure reductions).

example of in in-closure reductions:
```
[ (f) [f! swap f! swap] ]
```

the only pattern of reduction is `[  ]!`.

```
@define swap [ (x) (y) x y ]

[1 2] [3 4] swap
[1 2] [3 4] [ (x) (y) x y ]!
[1 2] [3 4] (x) (y) x y
[1 2] (y) x y
x y
[3 4] y
[3 4] [1 2]

// variable bound by @define, is different from
// variable bound by (x) and (y).
```

# Definition of Value

An expression with a constructor at the top is called a value.

这种对 Value 的定义，好像很适合 lazy language。
也就是说 Dan 的理解，可能比 David 的实现要深刻一些。

# Definition of Neutral

Expressions that are not values
and cannot yet be evaluated due to a variable
are called neutral.

这个定义是出现在下一章的，
我先写在这里做对比。

# Definition of constructor

Some expressions, such as Nat or (Pair Nat Atom), are types.

Part of explaining a new type
is to say what its constructors are.
The constructor expressions are the direct ways
of building expressions with the new type.

# Value, Neutral & Normal as predicates or subsets of Exp

注意，当定义这些术语时，Dan 是通过给 Exp 的集合分类来作出定义的。

首先定义的是 Normal。
"The normal form of an expression is the most direct way of writing it."
与实现中不同，定义用的不是 "带有 Type 的 Value"。
- 而且在实现中用到了 NotYetValue，它其实是 Neutral，但是实现中它被嵌入在了 Value 里。

其次是 Value。
"An expression with a constructor at the top is called a value."
现在我们有：Normal <: Value <: Exp
- Normal <: Value 是错误的
然后我们可以定义：Neutral = Exp - Value
或者说：Neutral = Non Value
并且有：Neutral + Value = Exp

最后是 Neutral。
"Expressions that are not values
and cannot yet be evaluated due to a variable
are called neutral."
也就是说，上面的 Neutral + Value = Exp 是错误的，
要加上 "尝试 evaluate，但因 var 而失败" 才正确。

# Definition of evaluation

Finding a value that is the same as
some starting expression is called evaluation.

What about the type? Sameness, after all, requires types.

From time to time, when talking about sameness,
we do not explicitly mention a type.
Nevertheless, a type is always intended,
and can be discovered by reading carefully.

Doesn't evaluation refer to
finding the meaning of an expression,
not just some simpler expression?

Not here. Expressions do not refer to some external notion of meaning
-- in Pie, there is nothing but expressions
and what we judge about them.

- In Lisp, values are distinct from expressions,
  and the result of evaluation is a value.

Everything Is an Expression

In Pie, values are also expressions.
Evaluation in Pie finds an expression,
not some other kind of thing.

A normal expression has no remaining opportunities for evaluation.
Usually, expressions that are normal are easier to understand.
Finding a value is often enough, however,
because the top constructor can be used to determine what must happen next.

可以说 David 所实现的 Pie 践行了这里的描述吗？
也许是 Dan 不对，因为当我们将 lambda evaluate 成 closure 时，
没法避免不去区分 Exp 与 Value。
